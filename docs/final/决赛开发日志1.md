# 决赛开发日志 by wdlin

我们认为在学习别人内核时有一个这样类似的文档，来记录各种遇到的 bug 和设计时的考虑是很好的。虽然我们经验还不充足，但是还是把自己的一些学习和思考都记录下来，一方面是自己记录先前所做的事情，还有一方面是如果之后有人无意间翻到了这个内核，希望能提供一些力所能及的帮助。

## 七月

### 2025.7.2

> 因为**信号**的设计用统一的 `TaskControlBlock` 来实现会更好，而且我们先前因为赶工没有太在意代码的可维护性和可读性，我们决定**重构**. 将现有的 `ProcessControlBlock` 和 `TaskControlBlock` 合为同一个结构体.

摆烂一天后开始进行重构，和队友分工，我负责修改线程块的部分，队友负责改地址空间.

`TaskStatus` 这种结构肯定是可以直接放在 `ProcessControlBlock` 的，不过 `exit_code` 就有点难说，因为这和进程组还有一点关系，最后或许还要和信号打交道.

打算这些部分就参考 rCore 的 ch6 来改了，比较幽默的是当时的 `heap_bottom` 和 `program_brk` 就是在 `ProcessControlBlock` 里面的，后来给我们改到 `TaskControlBlock` 又改回去了.

简直不知道从何改起. 令人感叹.

到处都是条件编译和各种莫名其妙的注释，决定先做 `tid` 的部分. 我接受不了当时到处写条件编译而不管可维护性的自己.

***

`TidHandler` 直接就迁移过来了. 然后把 `TaskContext` 的 `s` 寄存器统一了，虽然 LoongArch 只有 10 个但是很不优雅. 或者之后单独切一个 `TaskContext` 放在 `hal` module 里,

### 2025.7.3

`KernelAddr` 是直接包裹 `usize`，主要还是为了在统一地址空间后进行内核地址与用户地址的区分. 

分配用户资源 `alloc_user_res` 首先在 `USER_TRAP_CONTEXT_TOP` 分配一个页的空间用作 Trap，然后在 `USER_STACK_TOP` 向低地址分配一个 `USER_STACK_SIZE` 的空间作为用户栈，`USER_TRAP_CONTEXT_TOP` 地址比 `USER_STACK_TOP` 高线程最大数量的页大小，也就是 Trap 的存放地址比用户栈高. 然后会在用户栈上预先映射一些段.

研究了一下 `sfence.vma`，发现这个 TLB 刷新的问题好像在 LA 下并不是那么简单，而且 LA 下本身就需要考虑 TLB 重填的问题，后面应该要重新设计. 说不定这时候转 polyhal 还来得及.

`exit_code` 的问题实际上和信号的机制是紧密连在一起的.

下面梳理信号机制：

`SignalFlags` 是由 `bitflags` 定义的信号集合，各种信号. `SigOp` 是 `SignalFlags::default_op()` 根据不同信号作出的处理操作的一个枚举类型. 这个是定义部分. `SigAction` 是信号处理的结构体，`sa_handler` 即用户自定义处理函数, `sa_flags` 即相应的标志位, `sa_restorer` 为当用户自定义处理函数运行完毕后跳转的地址, `sa_mask` 为运行该信号处理函数时需要阻塞的信号.

```rust
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct SigAction {
    pub sa_handler: usize,
    pub sa_flags: SigActionFlags,
    pub sa_restore: usize,
    pub sa_mask: SignalFlags,
}
```

`KSigAction` 添加一个自定义标志判断是否使用默认处理函数.

```rust
#[derive(Clone, Copy)]
pub struct KSigAction {
    pub act: SigAction,
    pub customed: bool,
}

impl KSigAction {
    pub fn ignore() -> Self {
        Self {
            act: SigAction {
                sa_handler: 1,
                sa_flags: SigActionFlags::empty(),
                sa_restore: 0,
                sa_mask: SignalFlags::empty(),
            },
            customed: false,
        }
    }
}
```

`SigTable`  维护一个信号表，封装 `SigTableInner`，`group_exit_code` 是一个进程内多个线程的退出码. `actions` 即是信号表本身根据信号编号调用对应处理函数.

```rust
pub struct SigTableInner {
    actions: [KSigAction; SIG_MAX_NUM + 1],
    group_exit_code: Option<i32>,
}

impl SigTable {
	...
    pub fn action(&self, signo: usize) -> KSigAction {
        self.get_ref().actions[signo]
    }
    pub fn set_action(&self, signo: usize, act: KSigAction) {
        self.get_mut().actions[signo] = act
    }
    pub fn exit_code(&self) -> i32 {
        self.get_ref().group_exit_code.unwrap()
    }
    ...
}
```

<span id="signal"></span>

内核对信号的处理如下，引自[[Linux中的信号处理机制 二] - 知乎](https://zhuanlan.zhihu.com/p/79062142)：

<img src="https://pica.zhimg.com/v2-dffe4da0dc9611f74eaa5463c328a022_1440w.jpg" style="zoom:100%;" />

内核中的信号处理函数即是 `handle_signal()`.

在修改过程中我就疑惑为什么一个更符合直觉的 ch8 中将 `ProcessControlBlock` 和 `TaskControlBlock` 分离的方法不是一个更为普遍采用的方法，后来我查询了[Linux 源码](https://elixir.bootlin.com/linux/v5.10.65/source/include/linux/sched.h#L648)，才发现 `TaskControlBlock` 才是更通用的. 既然使用了同一个结构体，那么是怎么区分进程和线程的呢？

此时才发现当需要自己设计内核的时候，自然地需要考虑 **WHY 的问题**而不是 WHAT 和 HOW. 而一般的教程要么告诉 WAHT 要么告诉 HOW，而很少有告诉 WHY 的问题.

### 2025.7.4

我的理解是进程和线程共同一个 `ProcessControlBlock`，也即 Linux  下的 `task_struct`. 每一个进程都有自己的 `pid`, `tid` 和 `ppid`. 在 Linux 下有 `tgid` 和 `pid` 的区分，每个线程有自己的 `pid` 而其 `tgid` 与主线程的 `pid` 相等，可以参考 [进程和线程的区别 ( LINUX系统 )](https://blog.csdn.net/whahu1989/article/details/83153191) 中的例子. 甚至可以说这两者的区别并不那么重要，当我使用 `PID2PCB` 的时候就取了一个带有进程号 `pid` 的线程.

```rust
lazy_static! {
    /// PID2PCB instance (map of pid to pcb)
    pub static ref PID2PCB: UPSafeCell<BTreeMap<usize, Arc<ProcessControlBlock>>> =
        unsafe { UPSafeCell::new(BTreeMap::new()) };
}
```

`exit_code` 现在被存放在 `SigTable` 下.

### 2025.7.5

尝试使用 `polyhal` 了. 但是这个内核可以说是**满目疮痍**，完全不知从何改起. 几乎和重新写没区别.

`ProcessControlBlock::new()` 里面有一个 `user` 逻辑，感觉放在和 `pid` 同级不是很好，之后或许考虑放在 `inner` 里面.

`trap_cx` 就用 `TrapFrame::new()` 分配一个页帧，具体的还没看. `task_cx` 就用 `KContext` 将内核栈的栈顶存在 `KContext` 里. 今天莫名很疲惫，什么也不想干，就这样吧.

### 2025.7.6

处理学校的事务.

### 2025.7.7

为什么往年的内核就可以直接使用 `data_flow!` 呢？或者不如说 `translate_refmut` 是在做什么事情？做的是将其他地址空间的 `ptr` 转换为内核地址空间的一个可变 `u8 slice`. 这里我认为是因为其跳板页或者说双页表机制让内核地址空间和用户地址空间完全隔离开来. 这个地方之后再改动.

将几个关键的方法例如 `new`, `exec` 和 `fork` 实现了. 

### 2025.7.8

清除了 `ProcessControlBlock` 的一些无用成员.

`polyhal` 自己有一个 `PageTable`，同时也定义了各种地址段. 感觉如果使用他们的页表那改动就太大了. 不过 LA 和 RV 可以更好做一个兼容.

`TaskControlBlock` 就是一个线程，不过我这里都叫它 `ProcessControlBlock`，实际上有点不对. 又改了这一部分.

Trap 部分和地址空间的高地址还没做好，但是想让他先过编译.

实际上这些部分改动太大，除了 `KContext` 还有 `TrapFrame`.

队友在分析地址空间地址，队友说：我想我知道为什么了，因为我们参考的代码是实现了懒分配和 COW 机制的，他们在 `mmap` 的时候使用了懒分配机制，也就是说，程序在使用这部分空间的时候会触发页面错误，从而进行懒分配，在懒分配的时候他们会对拥有 `PTEFlags::W` 标志位的 `pte` 设置 COW 位，之后如果该进程 `fork` 子进程，子进程也想使用这个空间时，就会进行 COW 位的判断和处理。但是我们的 `mmap` 是实时分配，也就是说，进程在使用 `mmap` 空间的时候不会触发懒分配的错误处理，也就没有设置 COW 位，之后子进程复制了父进程的地址空间，在子进程想使用这个空间的时候，触发 COW 错误，但是由于没有设置 COW 位，所以判断失败，也就没有正确处理这个错误，以至于 `page fault` 没有解决，程序空转。

### 2025.7.9

改 `KContext` 和 `TrapFrame`. 首先先明晰 `task_cx` 任务上下文是进程/线程切换时的上下文，而 `trap_cx` 是处理器发生中断、异常和系统调用等时的上下文.

整理一下 `task_cx` 所做的事情：

在新建一个 `TaskContext` 或者说 `KContext` 实际上做的是类似的事情，都是定义 `ra`, `sp` 和通用寄存器

```rust
pub fn goto_trap_loop(kstack_ptr: usize) -> Self {
    Self {
        ra: trap_loop as usize,
        sp: kstack_ptr,
        s: [0; 12],
    }
}

fn blank_kcontext(ksp: usize) -> KContext {
    let mut kcx = KContext::blank(); // s在此被建立了
    kcx[KContextArgs::KPC] = task_entry as usize;
    kcx[KContextArgs::KSP] = ksp;
    kcx[KContextArgs::KTP] = read_current_tp();
    kcx
}
```

`trap_loop as usize` 的操作是返回一个函数指针，实际上就是在后续让其进行跳转. 之后就是进入对应的处理函数了：

```rust
#[no_mangle]
pub fn trap_loop() {
    loop {
        trap_return();
        trap_handler();
    }
}

fn task_entry() {
    trace!("os::task::task_entry");
    let task = current_task()
        .unwrap()
        .inner
        .exclusive_access()
        .get_trap_cx() as *mut TrapFrame;
    // run_user_task_forever(unsafe { task.as_mut().unwrap() })
    let ctx_mut = unsafe { task.as_mut().unwrap() };
    loop {
        run_user_task(ctx_mut); // polyhal的内置函数
    }
}
```

`trustos` 的 Trap 处理涉及更多：

```rust
#[no_mangle]
pub fn trap_return() {
    //检查信号
    if let Some(signo) = check_if_any_sig_for_current_task() {
        debug!("found signo in trap_return");
        handle_signal(signo);
    }

    if scause::read().cause() == Trap::Interrupt(scause::Interrupt::SupervisorTimer) {
        set_next_trigger();
    }

    // log::info!("return to user");

    set_user_trap_entry();
    extern "C" {
        #[allow(improper_ctypes)]
        fn __return_to_user(cx: *mut TrapContext);
    }
    unsafe {
        // 方便调试进入__return_to_user
        let trap_cx = current_trap_cx();
        // debug!("return to user,trap_ctx={:?}", trap_cx);
        __return_to_user(trap_cx);
    }
}

#[no_mangle]
/// handle an interrupt, exception, or system call from user space
pub fn trap_handler() {
    //记录用户空间花费CPU时间，同时准备内核空间花费CPU时间
    current_task()
        .unwrap()
        .inner_lock()
        .time_data
        .update_utime();
    set_kernel_trap_entry();
    let scause = scause::read();
    let stval = stval::read();
    match scause.cause() {
        ...
    }
    //检查定时器
    current_task().unwrap().check_timer();

    //记录内核空间花费CPU时间，同时准备用户空间花费CPU时间
    current_task()
        .unwrap()
        .inner_lock()
        .time_data
        .update_stime();
}
```

rCore 原来应该是调用 `trap_handler` 然后在末尾调用 `trap_return` 的. `set_user_trap_entry` 是处理地址空间不一致的问题的办法，详见[基于地址空间的分时多任务](https://learningos.cn/rCore-Camp-Guide-2025S/chapter4/6multitasking-based-on-as.html?highlight=set_user_trap_entry#trap). `stvec` 是 Supervisor Trap Vector Base Address Register，即“中断向量表基址”.

在用户进程运行时，`stvec` 应该指向 `__trap_from_user` 作为 用户陷阱入口。当用户态发生陷阱（中断、异常、系统调用）时，CPU会跳转到 `__trap_from_user`.

```assembly
# user -> kernel
__trap_from_user:
    csrrw sp, sscratch, sp
    # now sp->*TrapContext in kernel space, sscratch->user stack
    # save other general purpose registers
    sd x1, 1*8(sp)
    # skip sp(x2), we will save it later
    # save x3~x31 (x4 is tp)
```

`__trap_from_user` 就是将所有的**用户寄存器**存到**内核栈**，和`polyhal` 的 `user_restore` 是类似的. `__return_to_user` 自然就是在内核栈上恢复用户寄存器了.

对于信号机制，我的理解是进入 `trap_loop` 已经是进入了内核态，然后在 `trap_return` 里进行信号处理调用 `handle_signal`，在这个函数内会先 `setup_frame` 保存内核的上下文在**用户栈**上. 因为根据[先前](#signal)所说的信号处理的机制实际上是在用户态进行的，那么我们就要跳转到用户态，然后从用户态恢复当前的上下文，这就决定了是从被跳转的态的栈上也就是用户栈上恢复了我们原来的态的上下文也就是内核态.

那为什么先处理信号后设置用户返回入口然后就返回了，存疑？那什么时候进入内核的 trap_handler 处理？答：看起来是为了解决调用文件系统的问题所以先返回了一次用户态. 感觉怪怪的，不知道为什么这么写.

`polyhal` 的内置函数定义很清晰，分为存用户上下文和从内核回调两个部分：

```rust
pub fn run_user_task(context: &mut TrapFrame) -> EscapeReason {
    user_restore(context); //包裹保存寄存器的asm
    kernel_callback(context).into() // 中断异常，类似于trap_handler
}
```

但无论是哪种实现，在 Trap 返回时都是需要获取当前的 `TrapContext` 或者说 `TrapFrame` 的，通过调用 `get_trap_cx` 或者 `current_trap_cx` 这种类似的函数来实现. 其实很符合逻辑，因为 Trap 到另一个态就是需要当前的上下文信息的.

那么自然的问题是，`TrapContext` 和 `TaskContext` 有什么区别呢？其实区别可太大了吧，首先是存放位置的区别，`TrapContext` 一般在内核栈栈顶，`TaskContext` 一般在任务控制块里. 相比于 `TrapContext`，`TaskContext` 只保存一些比较重要的寄存器而不是全部的状态信息. 而且他们的目标也是不一样的，`TrapContext` 是用户态和内核态的切换问题，实现依赖 CPU 的陷阱机制，而 `TaskContext` 是内核态任务的主动切换，依靠的是 `__switch` 这一纯软件的实现方式.

| **特性**       | `trap_context`                        | `task_context`                   |
| :------------- | :------------------------------------ | :------------------------------- |
| **触发时机**   | 用户态→内核态的陷阱（中断/异常）      | 内核态任务主动切换               |
| **保存位置**   | 当前任务的内核栈顶                    | 任务控制块（TCB）                |
| **数据完整性** | 完整用户状态 + 陷阱元数据             | 仅切换所需的关键寄存器           |
| **恢复目标**   | 返回原用户任务                        | 切换到另一个内核任务             |
| **硬件依赖**   | 依赖 CPU 的陷阱机制（如 RISC-V Trap） | 纯软件实现（如 `__switch` 函数） |

一个 `__switch` 一般是这样的：

```rust
global_asm!(include_str!("switch.S"));

extern "C" {
    pub fn __switch(current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext);
}
```

为了给 `polyhal` 加入信号处理的机制，需要让 `TrapFrame` 能与我们自己定义的 `MachineContext` 和 `UserContext` 能够实现转换. 试了许多方法，最后感觉还是实现一个 `trait` 再 `impl` 其上比较简单.

`trap_cx` 应该有一个 `origin_a0` 的机制，在处理信号为 `SA_RESTART` 时进行处理，这需要改 `polyhal` 底层，目前先让其过编译，之后用到了再修改.

### 2025.7.10

不知道这个 `ARCH_INIT_TIMER` 有甚么用. 如果直接使用 `polyhal-boot` 会有 `PageTable` 的问题，就得用他们的数据结构了. 所以启动的部分还是得自己改.

但是想要启动起来就必须删去跳板页：

```assembly
rust-lld: error: undefined symbol: trampoline
          >>> referenced by os.e36b250b2cfb0a60-cgu.13
          >>>               /home/lc/osrepo/os/target/riscv64gc-unknown-none-elf/release/deps/os-d7d907be1afa0e3a.os.e36b250b2cfb0a60-cgu.13.rcgu.o:(.text.entry+0x2E)
          >>> did you mean: strampoline
          >>> defined in: src/linker_rv.ld:14
```

然后就删去了跳板页，勉强过了编译，但是内核无法启动，卡在 OpenSBI 处.

### 2025.7.11

设置 `BASE_ADDRESS = 0xffffffc080200000`，但是内核无法启动. 难以理解，相当于没有进入内核，但是链接脚本和 `boot` 都看起来没什么问题.

在链接脚本里设置 `BASE_ADDRESS` 为低地址就可以启动了，但是打印出来的地址映射都是高地址，这是否有点离谱了. 难道这个不就是内核的入口起始地址吗，简直就是倒反天罡.

根据 [TrustOS 的设计文档](https://gitee.com/B4holder/trust-os/blob/final/chapter2_内存管理.md) 和 [chaos 开发日志](https://sazikk.top/posts/开发日志-chaos开发日志/#修改内核地址空间)，设置 `BASE_ADDRESS` 不应该有什么问题，我只能理解为是 `RustSBI` 和 `OpenSBI` 的差异，因为我也没读过他们的源码. 根据 TrustOS 文档的说法，改变内核入口并不会影响到物理内存中由 `0x8020_0000` 开始的一段，所以即使内核入口已经设置为了高位的虚拟地址，所以内核还是可以正常执行的，只需要考虑启动虚拟映射之后将代码映射到高位. 但如果 `OpenSBI` 并不是相同的逻辑，而是就根据链接脚本定义的虚拟地址来寻找 `_start` 各段，那么设置了高地址的 `BASE_ADDRESS` 就会让所有符号诸如 `_start = 0xffffffc080200000` 为高位的虚拟地址，同时 `boot` 中所做的映射高位的大页机制中诸如 `sp` 和 `t0` 也就自动被认为是高位地址了，因为 `la` 指令加载的是由链接脚本决定的符号的虚拟地址.

```assembly
la sp, boot_stack_top   # sp = 高虚拟地址 (0xffffffc0802xxxxx)
la t0, boot_pagetable   # t0 = 高虚拟地址 (0xffffffc0802xxxxx)
```

因为在内核刚加载的一段时间分页机制还没有开启，所以一直都是在访问物理地址，访问高虚拟地址自然就会引发错误，无法处理导致卡死.

如果在 `FRAME_ALLOCATOR` 中设置

```rust
FRAME_ALLOCATOR.exclusive_access().init(
    // Frame allocator initialized: 0xffffc082272 - 0xffffc088000
    PhysAddr::from(ekernel as usize).ceil(),
    PhysAddr::from(MEMORY_END).floor(),
);
```

而不是

```rust
FRAME_ALLOCATOR.exclusive_access().init(
    // Frame allocator initialized: 0x82272 - 0x88000
    PhysAddr::from(KernelAddr::from(ekernel as usize)).ceil(),
    PhysAddr::from(KernelAddr::from(MEMORY_END)).floor(),
);
```

就会导致内核卡死，`KernelAddr` 是对 `usize` 的直接包裹，只用来注明这是内核的高地址空间，转换为 `PhysAddr` 时直接减去 `KERNEL_ADDR_OFFSET`. 对于物理页帧分配器，需要的确实应当是低位的物理地址而不是虚拟地址.

但是在 `activate` 里写入 `satp` 就会卡死：

```rust
pub fn activate(&self) {
    let satp = self.page_table.token();
    unsafe {
        satp::write(satp);
        asm!("sfence.vma"); 
    }
}
```

我理解的是 `ppn` 段的内容 `0x82282` 没有被正确映射，导致的问题：

```assembly
kernel satp: 0x8000000000082282
.text [0xffffffc080200000, 0xffffffc080248000)
.rodata [0xffffffc080248000, 0xffffffc080257000)
.data [0xffffffc080257000, 0xffffffc080260000)
.bss [0xffffffc080260000, 0xffffffc082282000)
sigreturn_trampoline : [0xffffffc080202000, 0xffffffc080203000)
physical memory: [0xffffffc082282000,0xffffffc088000000)
[DEBUG] MapArea::new(as vpn) start floor = 0x4080200, end ceil = 0x4080202
[DEBUG] MapArea::new(as vpn) start floor = 0x4080203, end ceil = 0x4080248
[DEBUG] MapArea::new(as vpn) start floor = 0x4080202, end ceil = 0x4080203
[ INFO] mapping .rodata section
[DEBUG] MapArea::new(as vpn) start floor = 0x4080248, end ceil = 0x4080257
[ INFO] mapping .data section
[DEBUG] MapArea::new(as vpn) start floor = 0x4080257, end ceil = 0x4080260
[ INFO] mapping .bss section
[DEBUG] MapArea::new(as vpn) start floor = 0x4080260, end ceil = 0x4082282
[ INFO] mapping physical memory
[DEBUG] MapArea::new(as vpn) start floor = 0x4082282, end ceil = 0x4088000
[ INFO] mapping memory-mapped registers
map mmio device,[0xffffffc000100000,0xffffffc000102000)
[DEBUG] MapArea::new(as vpn) start floor = 0x4000100, end ceil = 0x4000102
map mmio device,[0xffffffc010001000,0xffffffc010002000)
[DEBUG] MapArea::new(as vpn) start floor = 0x4010001, end ceil = 0x4010002
create new kernel successfully!
[DEBUG] activate memory set, satp = 0x8000000000082282
[DEBUG] satp = 0x8000000000082282
```

### 2025.7.12

没啥头绪解决，算了. `satp` 先放着.

然后是 `trap` 的问题. 我们现在的 `trap` 和 `polyhal` 的混在一起，感觉可能整个结构还是得用 `polyhal` 来改写. 但是好累，不想改.

打算正式迁移 `polyhal` 了，因为后面无论是上板还是其余的一些功能的实现都会用到. 首先要做的就是修改链接脚本. 看过之后我只能说 `polyhal` 更懂启动. 

用 `polyhal` 启动了内核.

### 2025.7.13

`polyhal` 来实现地址空间，`PageTable` 的部分是他们已经实现了的，所有 `MapArea` 相关的部分还保存着.

但是所有涉及 `PageNum` 的部分都需要修改. 先前的 rCore 是用 `floor` 和 `ceil` 方法来实现由地址向页号的转换，这里 `polyhal` 虽然也使用了同名的方法，但是返回值仍然是地址而不是页号. 变量名虽然还是 `vpn`，但是是经过**页对齐**过后的 `VirtAddr`. 页表的 `translate` 方法变为：

```rust
polyhal::pagetable::PageTable
pub fn translate(&self, vaddr: VirtAddr) -> Option<(PhysAddr, MappingFlags)>
```

而且 `MapType` 的差别也被删掉了.

很奇怪，`polyhal` 的实现似乎并不需要 `token`.

我理解的是，用户态和内核态有两个页表，这就是[SaZiKK 一直说的双页表机制](https://sazikk.top/posts/开发日志-chaos开发日志/#2024619-开始重构). 内核的页表就是 `KERNEL_SPACE` 下的页表，如果他们共用一个页表，就完全颠覆了 [跨空间跳板内核](https://rustmagazine.github.io/rust_magazine_2021/chapter_7/trampoline-kernel.html) 的结构. 所以极其精简的 `translated_byte_buffer` 是有原因的：

```rust
pub fn translated_byte_buffer(_token: PageTable, ptr: *mut u8, len: usize) -> &'static mut [u8] {
    trace!("os::mm::page_table::translated_byte_buffer");
    unsafe { core::slice::from_raw_parts_mut(ptr, len) }
}
```

`GROUP_SHARE` 原本都是 `ppn` 到 `FrameTracker` 的映射，记得改过来，现在是对齐过后的 `VirtAddr`. 

修改 `MemorySet` 时都保留了 `vpn` 的说法，但是这是对齐过后的虚拟地址. 

一般的 `VirtAddr` 向 `VirtPageNum` 的转换是 `floor`.

### 2025.7.14

每个进程都有其对应的地址空间，自然也有其对应的页表，当时 `polyhal` 直接删除了这一部分. 犹豫如何修改：

```rust
// MemorySetInner::lazy_clone_area
let mut origin_page_table = PageTable::from_token(self.page_table.token());
let another_page_table = PageTable::from_token(another.page_table.token());
for vpn in another_area.vaddr_range {
    let src_pte = another_page_table.translate(vpn);
    if src_pte.is_none() || !src_pte.unwrap().is_valid() {
        continue;
    }
    let src_ppn = src_pte.unwrap().ppn();

    let dst_pte = origin_page_table.translate(vpn);
    if dst_pte.is_none() || !dst_pte.unwrap().is_valid() {
        this_area.map_one(&mut origin_page_table, vpn);
    }
    let dst_ppn = origin_page_table.translate(vpn).unwrap().ppn();
    dst_ppn
    .bytes_array_mut()
    .copy_from_slice(src_ppn.bytes_array());
}
```

页表的切换，或者说进程页表 `satp` 的切换是在 `TaskControlBlock::exec` 里调用 `memory_set.activate()` 实现的.

`PhysAddr` 和 `VirtAddr` 不需要在 `translated_byte_buffer` 实现转换，应当是因为 `VirtAddr` 和 `PhysAddr` 都是对 `usize` 的简单包裹？但这不对吧，`translated_byte_buffer` 实际上是用户态和内核态转换使用到的，所以实际上这是因为内核态和用户态的双页表机制被取消了，也就是 [chaos/docs/决赛第一阶段文档.md at main · chaos-kernel/chaos](https://github.com/chaos-kernel/chaos/blob/main/docs/决赛第一阶段文档.md#22-内存管理). 因为不用跳板页了.

然后说回这个 `lazy_clone_area` 的问题，因为是在 `clone_user_res` 里调用，实际上是不同进程间地址空间的复制，所以必然是要做页表切换的.

`safe_translated_byte_buffer` 实际上就是 `translated_byte_buffer` 在查找 `PageTableEntry`过程中的惰性处理. 因为已经取消了内核页表与应用页表的区别，所以查找页表项也不必要了，删.

### 2025.7.15

TrustOS 的内核栈上存放着 `task_cx`. 原本的设计在 `KERNEL_SAPCE` 和用户的 `memory_set` 分别映射同一段逻辑段应当是为了在上下文切换时保持合理的地址访问.

需要重写整个信号处理机制，但是目前来说还做不到，而且不知道会出现什么问题. 先放着.

一切都改好了，发现 OpenSBI 的启动地址不一样，后续的地址空间也无法被构建起来

```bash
lc@806-os:~/osrepo$ riscv64-unknown-elf-readelf -h kernel-rv
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - GNU
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           RISC-V
  Version:                           0x1
  Entry point address:               0xffffffc080200000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          17567816 (bytes into file)
  Flags:                             0x5, RVC, double-float ABI
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         7
  Size of section headers:           64 (bytes)
  Number of section headers:         25
  Section header string table index: 23
```

### 2025.7.16

修高位地址的启动问题.

首先先修复了 vendor 里会重复引入 polyhal 宏的问题，一个小 bug.

但是不知道为什么无法将链接脚本里的地址转换为物理地址.

答：换成 `os.bin` 就可以了. 因为 OpenSBI 会根据文件格式进行解析，如果是 ELF 格式就会按照其 Entry 的虚拟地址进行加载，而 bin 文件会无条件加载到 `0x80200000`.

至此可以说**基本**完成了初赛结束以来的重构.

### 2025.7.17

`KernelAddr::from()` 之后再 `kernel_va as *mut u8` 和 `get_mut_ptr::<u8>()` 是一样的. 修复了原本 `bytes_array_mut` 一类的问题.

```rust
// dst_ppn
//   .bytes_array_mut()
//   .copy_from_slice(src_ppn.bytes_array());
let src_paddr: *const u8 = src_paddr.get_ptr::<u8>();
let dst_paddr: *mut u8 = dst_paddr.get_mut_ptr::<u8>();
let dst_array = unsafe {
    core::slice::from_raw_parts_mut(dst_paddr, PAGE_SIZE)
};
dst_array.copy_from_slice(
    unsafe {
        core::slice::from_raw_parts(src_paddr, PAGE_SIZE)
    }
);
```

切换上下文有问题.

***

剩余的部分还在整理，目前正在赶进度，在现场赛前都会提交。