# 决赛第一阶段开发文档

- [决赛第一阶段开发文档](#决赛第一阶段开发文档)
  - [1. 概述](#1-概述)
  - [2. SubsToKernel 设计与实现](#2-substokernel-设计与实现)
    - [2.1 进程管理](#21-进程管理)
      - [2.1.1 进程与线程控制块](#211-进程与线程控制块)
      - [2.1.2 进程调度](#212-进程调度)
      - [2.1.3 异常与中断](#213-异常与中断)
    - [2.2 内存管理](#22-内存管理)
      - [2.2.1 地址空间布局](#221-地址空间布局)
      - [2.2.2 内存映射](#222-内存映射)
      - [2.2.3 堆管理](#223-堆管理)
    - [2.3 文件系统](#23-文件系统)
      - [2.3.1 虚拟文件系统](#231-虚拟文件系统)
      - [2.3.2 EXT4 文件系统支持](#232-ext4-文件系统支持)
      - [2.3.3 文件描述符管理](#233-文件描述符管理)
    - [2.4 信号机制](#24-信号机制)
      - [2.4.1 信号处理框架](#241-信号处理框架)
      - [2.4.2 信号传递机制](#242-信号传递机制)
    - [2.5 HAL 硬件抽象层](#25-hal-硬件抽象层)
      - [2.5.1 架构适配设计](#251-架构适配设计)
      - [2.5.2 内存管理适配](#252-内存管理适配)
    - [2.6 网络机制](#26-网络机制)
      - [2.6.1 Socket 系统调用](#261-socket-系统调用)
      - [2.6.2 网络协议栈](#262-网络协议栈)
  - [3. 总结与展望](#3-总结与展望)

## 1. 概述

`SubsToKernel` 是使用 `Rust` 语言基于 [2025春夏季开源操作系统训练营 rCore 项目](https://github.com/LearningOS/rust-based-os-comp2025/blob/main/2025-spring-summary.md) 设计的操作系统内核，支持 RISC-V/LoongArch 两个架构，兼容 POSIX 协议。本项目在决赛阶段实现了完整的进程管理、内存管理、文件系统、信号机制、跨架构 HAL 设计以及网络功能。

队员来自北京科技大学，成员及分工如下：

- 吴函霖：内存管理、网络模块、进程结构体重构、部分 syscalls 实现；
- 刘畅：文件系统、信号机制、架构适配重构、部分 syscalls 实现。

## 2. SubsToKernel 设计与实现

### 2.1 进程管理

决赛阶段，我们对进程管理模块进行了重构。采用 PCB 和 TCB 分离的设计，实现了更清晰的进程与线程管理架构。

#### 2.1.1 进程与线程控制块

我们使用 `ProcessControlBlock`(PCB) 和 `TaskControlBlock`(TCB) 分别管理进程和线程，PCB 中包含一个 TCB 数组用来存放一个进程的所有线程:

```rust
/// Process Control Block
pub struct ProcessControlBlock {
    ///ppid
    pub ppid: usize,
    /// immutable
    pub pid: usize,
    /// immutable default user
    pub user: Arc<User>,
    /// mutable
    inner: UPSafeCell<ProcessControlBlockInner>,
}
```

PCB 的内部结构包含了进程的所有资源管理，相比于原先的版本，我们添加了信号、堆管理和计时器等机制，并改写了文件管理和地址空间的实现：

```rust
pub struct ProcessControlBlockInner {
    /// is zombie?
    pub is_zombie: bool,
    /// memory set(address space)
    pub memory_set: Arc<MemorySet>,
    /// parent process
    pub parent: Option<Weak<ProcessControlBlock>>,
    /// children process
    pub children: Vec<Arc<ProcessControlBlock>>,
    /// exit code
    pub exit_code: i32,
    /// file descriptor table
    pub fd_table: Arc<FdTable>,
    /// fs info
    pub fs_info: Arc<FsInfo>,
    /// signal flags
    pub signals: SignalFlags,
    /// tasks(also known as threads)
    pub tasks: Vec<Option<Arc<TaskControlBlock>>>,
    /// task resource allocator
    pub task_res_allocator: RecycleAllocator,
    /// mutex list
    pub mutex_list: Vec<Option<Arc<dyn Mutex>>>,
    /// semaphore list
    pub semaphore_list: Vec<Option<Arc<Semaphore>>>,
    /// condvar list
    pub condvar_list: Vec<Option<Arc<Condvar>>>,
    /// priority
    pub priority: usize,
    /// stride
    pub stride: Stride,
    /// process tms
    pub tms: Tms,
    /// signal table
    pub sig_table: Arc<SigTable>,
    /// clear child tid
    pub clear_child_tid: usize,
    /// heap management
    pub heap_id: usize,
    pub heap_bottom: usize,
    pub heap_top: usize,
    /// robust list
    pub robust_list: RobustList,
    /// timer
    pub timer: Arc<Timer>,
}
```

TCB 中包含一个对自己所属进程的弱引用，避免循环引用的同时能够访问进程资源。相比于原本的 rCore 实现，我们删除了 `TaskUserRes`，使其结构更加清晰，有利于对进程资源的管理:

```rust
pub struct TaskControlBlock {
    /// immutable
    pub process: Weak<ProcessControlBlock>,
    /// Kernel stack corresponding to TID
    pub kstack: KernelStack,
    /// mutable
    inner: UPSafeCell<TaskControlBlockInner>,
}

pub struct TaskControlBlockInner {
    pub tid: usize,
    pub ptid: usize,
    /// Trap cx phys page number
    pub trap_cx_ppn: PhysPageNum,
    /// Trap virtual address
    pub trap_va: VirtAddr,
    /// Save task context, 线程上下文
    pub task_cx: TaskContext,
    /// Maintain the execution status of the current process
    pub task_status: TaskStatus,
    /// It is set when active exit or execution error occurs
    pub exit_code: Option<i32>,
    /// User stack top
    pub ustack_top: VirtAddr,
    /// Signal mask
    pub sig_mask: SignalFlags,
    /// Signal pending
    pub sig_pending: SignalFlags,
}
```

每个成员如注释所述，对子进程持强引用，对父进程持弱引用的方法可以防止循环引用造成的内存泄漏。

#### 2.1.2 进程调度

为了确保异步安全，我们使用 `Arc` 包裹 PCB 和 TCB，并使用内部可变性模式管理可变状态：

```rust
pub struct UPSafeCell<T> {
    /// inner data
    inner: RefCell<T>,
}

unsafe impl<T> Sync for UPSafeCell<T> {}

impl<T> UPSafeCell<T> {
    /// User is responsible to guarantee that inner struct is only used in
    /// uniprocessor.
    pub unsafe fn new(value: T) -> Self {
        Self {
            inner: RefCell::new(value),
        }
    }
    /// Panic if the data has been borrowed.
    pub fn exclusive_access(&self) -> RefMut<'_, T> {
        self.inner.borrow_mut()
    }
    pub fn borrow(&self) -> RefMut<'_, T> {
        self.inner.borrow_mut()
    }
    pub fn get_unchecked_mut(&self) -> &mut T {
        unsafe { &mut *self.inner.as_ptr() }
    }
    pub fn get_unchecked_ref(&self) -> &T {
        unsafe { &*self.inner.as_ptr() }
    }
}
```

`RefCell` 是 Rust 标准库中的一个类型，提供了在运行时进行可变借用检查的能力。它允许在单线程环境中进行内部可变性（interior mutability）。`Sync` 是一个标记 trait，表示类型可以安全地在多个线程间共享引用。`RefCell` 本身不是 `Sync` 的，因为它只在单线程环境中保证安全，因此我们通过 `unsafe impl` 声明，承诺 `UPSafeCell` 可以安全地在多线程环境中共享。在多核环境下，这种方法并不安全，只是一种在多核尚未实现的情况下的临时措施。

线程状态管理包括四种状态：
- `Ready`：就绪状态，等待调度
- `Block`：阻塞状态，等待某些条件满足
- `Running`：运行状态，正在执行
- `Exit`：退出状态，线程已结束

调度算法采用时间片轮转结合 Stride 调度：

```rust
pub fn run_tasks() {
    loop {
        let mut processor = PROCESSOR.exclusive_access();
        if let Some(task) = fetch_task() {
            let idle_task_cx_ptr = processor.get_idle_task_cx_ptr();
            // 上下文切换和任务执行逻辑
            ...
            processor.current = Some(task);
            drop(processor);
            unsafe {
                __switch(idle_task_cx_ptr, next_task_cx_ptr);
            }
        } else {
            check_timer();
        }
    }
}
```

任务之间的切换通过访问 `__switch` 这个符号来实现，其作用是保存一个任务的上下文而恢复另一个任务的上下文，也就是与当前这个任务相关的寄存器内容。

用户态向内核态的切换通过访问 `__alltraps` 这个符号进行，其实现方式是切换内核栈与用户栈的指针，保存当前的上下文，包括通用寄存器、浮点寄存器、当前地址空间 token 和 `sepc`(`prmd`) 寄存器等到内核栈上，然后将 `sp` 指针切换为用户栈后返回，从内核态切换到用户态的 `__restore` 符号做的是类似的操作。

#### 2.1.3 异常与中断

我们的系统支持处理不同架构下的异常与中断，通过条件编译适配 RISC-V 和 LoongArch：

```rust
#[cfg(target_arch = "riscv64")]
pub fn trap_handler() -> ! {
    // RISC-V 特定的 trap 处理
}

#[cfg(target_arch = "loongarch64")]
pub fn trap_handler() -> ! {
    // LoongArch 特定的 trap 处理
}
```

`TRAMPOLINE` 和 `strampoline` 跳板页地址即是 `__alltraps` 的符号地址，通过 `set_user_trap_entry` 设置用户中断入口：

```rust
#[inline]
/// 设置普通异常和中断入口
fn set_user_trap_entry() {
    #[cfg(target_arch = "riscv64")]
    unsafe {
        stvec::write(TRAMPOLINE as usize, TrapMode::Direct);
    }

    #[cfg(target_arch = "loongarch64")]
    eentry::set_eentry(strampoline as usize);
}
```

跳转至 `__alltraps` 后会在汇编代码的末尾跳转 `trap_handler` 这个用户态处理中断例外的函数，处理具体的 Exception 例外。

处理后回到用户态，通过 `trap_retrun` 函数计算 `__restore` 这个符号的地址然后跳转，以 RISCV 架构下为例：

```rust
#[cfg(target_arch = "riscv64")]
#[no_mangle]
pub fn trap_return() -> ! {
    if let Some(signo) = check_if_any_sig_for_current_task() {
        debug!("found signo in trap_return");
        handle_signal(signo);
    }
    set_user_trap_entry();
    let trap_cx_user_va = current_trap_cx_user_va();
    let user_satp = current_user_token();

    let restore_va = __restore as usize - __alltraps as usize + TRAMPOLINE;
    unsafe {
        asm!(
            "fence.i",
            "jr {restore_va}",         // jump to new addr of __restore asm function
            restore_va = in(reg) restore_va,
            in("a0") trap_cx_user_va,      // a0 = virt addr of Trap Context
            in("a1") user_satp,        // a1 = phy addr of usr page table
            options(noreturn)
        );
    }
}
```

内核态的例外处理入口设置：

```rust
#[inline]
fn set_kernel_trap_entry() {
    #[cfg(target_arch = "riscv64")]
    unsafe {
        stvec::write(__trap_from_kernel as usize, TrapMode::Direct);
    }

    #[cfg(target_arch = "loongarch64")]
    eentry::set_eentry(__trap_from_kernel as usize);
}
```

然后即会跳转到 `__trap_from_kernel` 这个符号，处理对应的例外。

### 2.2 内存管理

我们重新设计了内存管理子系统，支持更灵活的地址空间布局和高效的内存分配策略。

#### 2.2.1 地址空间布局

地址空间被重新规划，用户栈和堆分别管理，避免相互冲突：

<img src="../img/memory.png" alt="memory" style="width: 60%;" />

内存布局从低地址到高地址依次为：
- 代码段和数据段
- 用户栈区域
- 保护页（Guard Page）
- 用户堆区域

```rust
pub struct MemorySetInner {
    /// page table
    pub page_table: PageTable,
    /// areas
    pub areas: Vec<MapArea>,
}
```

#### 2.2.2 内存映射

使用 `MapArea` 管理不同类型的内存区域：

```rust
pub struct MapArea {
    pub vpn_range: VPNRange,
    pub data_frames: BTreeMap<VirtPageNum, Arc<FrameTracker>>,
    pub map_type: MapType,
    pub map_perm: MapPermission,
    pub area_type: MapAreaType,
    pub mmap_file: MmapFile,
    pub mmap_flags: MmapFlags,
    pub groupid: usize,
}
```

物理页帧使用 RAII 管理，确保内存安全：

```rust
pub struct FrameTracker {
    pub ppn: PhysPageNum,
}

impl Drop for FrameTracker {
    fn drop(&mut self) {
        frame_dealloc(self.ppn);
    }
}
```

#### 2.2.3 堆管理

堆的管理信息维护在 PCB 中，支持动态扩展：

```rust
// 在 ProcessControlBlockInner 中
pub heap_id: usize,
pub heap_bottom: usize,
pub heap_top: usize,
```

### 2.3 文件系统

文件系统设计目标是最大程度将文件系统与内核解耦合，降低内核的复杂度，目前我们已经实现了解耦合的基本目标，支持了 EXT4 文件系统。

#### 2.3.1 虚拟文件系统

基于 Rust 提供的 `trait` 机制，抽象为 `SuperBlock`, `Inode` 和 `File` 特性，任何实现了这些 `trait` 的对象都可以作为任意一个文件系统的模块，由此可以消除不同文件系统的差异，以便支持不同的文件系统。只需要调用 `trait` 中定义的方法即可对文件系统实现统一的操作。部分定义如下：

```rust
pub trait SuperBlock: Send + Sync {
    fn root_inode(&self) -> Arc<dyn Inode>;
    fn sync(&self);
    fn fs_stat(&self) -> Statfs;
    fn ls(&self);
}
```

其中 `SuperBlock` 对应文件系统的管理器，负责提供整个文件系统的信息，对外提供根节点 `root_inode` 进行调用，同时负责文件系统的磁盘刷新操作。

```rust
pub trait Inode: Send + Sync {
    fn size(&self) -> usize;
    fn types(&self) -> InodeType;
    fn is_dir(&self) -> bool;
    fn fstat(&self) -> Kstat;
    /// 创建文件或目录
    fn create(&self, _path: &str, _ty: InodeType) -> Result<Arc<dyn Inode>, SysErrNo>;
    /// 查找文件
    fn find(&self, _path: &str, _flags: OpenFlags, _loop_times: usize) -> Result<Arc<dyn Inode>, SysErrNo>;
    fn read_at(&self, _off: usize, _buf: &mut [u8]) -> SyscallRet;
    fn write_at(&self, _off: usize, _buf: &[u8]) -> SyscallRet;
    /// 读取目录项
    fn read_dentry(&self, _off: usize, _len: usize) -> Result<(Vec<u8>, isize), SysErrNo>;
    ...
}
```

`Inode` 对应的是文件系统中的具体文件，在后续我们有 `impl Inode for Ext4Inode` 以具体实现文件节点，对读写、增删查改等一系列接口进行封装以供上层调用。

```rust
pub trait File: Send + Sync {
    fn readable(&self) -> bool;
    fn writable(&self) -> bool;
    /// 对缓冲区的读操作
    fn read(&self, _buf: UserBuffer) -> SyscallRet;
    /// 对缓冲区的写操作
    fn write(&self, _buf: UserBuffer) -> SyscallRet;
    fn fstat(&self) -> Kstat;
    ...
}
```

`File` 对应在内核中具体使用的文件，这是一个十分泛用的接口，可以 `impl` 在抽象的文件、输出流、管道和设备上。

除此之外，还要实现给内核其他部分的文件处理的接口，方便进行文件的读写增改查操作。

```rust
pub struct OSInode {
    readable: bool, // 该文件是否允许通过 sys_read 进行读
    writable: bool, // 该文件是否允许通过 sys_write 进行写
    pub inode: Arc<dyn Inode>,
    pub(crate) inner: Mutex<OSInodeInner>,
}
#[derive(Debug)]
pub struct OSInodeInner {
    pub(crate) offset: usize, // 偏移量
}
```

`OSInode` 是文件系统给内核的接口，诸如诸如 `open()` 等一般的内核对文件的操作的返回值类型，由此实现对文件的控制。文件系统架构图如下：

```mermaid
graph TB
    Disk[Disk]
    Disk --> dev("BlockDeviceImpl")
    Inode[trait Inode]
    SuperBlock[trait SuperBlock]
    Ext4SuperBlock[Ext4SuperBlock]
    File[trait File]
    Ext4File[Ext4File]
    Ext4Inode[Ext4Inode]
    OSInode[OSInode]
    
    SuperBlock -.-> Ext4SuperBlock
    SuperBlock --> Inode
    Ext4SuperBlock --> Disk
    Ext4SuperBlock --> Ext4Inode
    Ext4Inode --> Ext4File
    File -.-> Ext4File
    OSInode --> Inode
    Inode -.-> Ext4Inode
    Inode -.-> OtherInode...
```


#### 2.3.2 EXT4 文件系统支持

我们使用 [elliott10/lwext4_rust](https://github.com/elliott10/lwext4_rust) 库实现 EXT4 支持：

```rust
pub struct Ext4SuperBlock {
    inner: UPSafeCell<Ext4BlockWrapper<Disk>>,
    root: Arc<dyn Inode>,
}
```

`Ext4SuperBlock` 中的 `inner` 封装着块设备驱动 `Disk`，其中 `UPSafeCell` 提供了线程安全的内部可变性； `root` 作为动态分发的根目录为文件系统操作提供起点。

```rust
pub struct Ext4Inode {
    inner: UPSafeCell<Ext4InodeInner>,
}

pub struct Ext4InodeInner {
    f: Ext4File,
    delay: bool,
    if_dir: bool,
}
```

`Ext4Inode` 提供着文件类型标志 `if_dir` 和延迟删除标志 `delay`，还有 `f` 作为 `Ext4File` 即实际的文件操作对象。

```rust
pub struct Ext4File {
    //file_desc_map: BTreeMap<CString, ext4_file>,
    file_desc: ext4_file,
    file_path: CString,

    this_type: InodeTypes,

    has_opened: bool,
    last_flags: u32,
}
```

`ext4_file` 是由 `lwext4_rust` 库封装的文件类型，`file_path` 为文件的绝对路径，`this_type` 作为 `InodeTypes` 是关于文件类型的枚举值，`has_opened` 是关于文件是否打开的标记，`last_flags` 是上次使用的打开标记。这些内容比较完整地描述了一个文件所需要的数据。

#### 2.3.3 文件描述符管理

文件描述符表管理进程的文件访问：

```rust
pub struct FdTable {
    inner: UPSafeCell<FdTableInner>,
}

pub struct FdTableInner {
    soft_limit: usize,
    hard_limit: usize,
    files: Vec<Option<FileDescriptor>>,
}
```

文件描述符表管理进程对打开文件的控制，用 `FdTableInner` 封装，分配新 `fd` 时会检查软阈值 `soft_limit`，而 `hard_limit` 是整个操作系统不可逾越的绝对资源上限值。

```rust
#[derive(Clone)]
pub enum FileClass {
    File(Arc<OSInode>),
    Abs(Arc<dyn File>),
}
#[derive(Clone)]
pub struct FileDescriptor {
    pub flags: OpenFlags,
    pub file: FileClass,
}
```

`FileClass` 对不同的文件提供不同的访问接口，而 `FileDescriptior` 作为文件描述符 `fd` 的实体用于封装文件的操作状态。`FileClass` 最后通过 `File` 这个 `trait` 连接到 `Ext4File` 类型。

### 2.4 信号机制

我们实现了 POSIX 信号机制，支持信号的发送、接收和处理。

信号是一种软件中断，用于通知进程发生了特定事件。它是一种进程间通信（IPC）的机制，允许内核或其它进程向目标进程发送通知，让其对事件做出响应。信号可以中断进程当前正在执行的任务，并转而执行预定义的信号处理程序。

#### 2.4.1 信号处理框架

`SignalFlags` 是由 `bitflags` 定义的信号集合，各种信号. `SigOp` 是 `SignalFlags::default_op()` 根据不同信号作出的处理操作的一个枚举类型。

```rust
/// Signal flags
bitflags! {
    pub struct SignalFlags: usize {
        const SIGHUP    = 1 << (SIGHUP -1);
        const SIGINT    = 1 << (SIGINT - 1);
        ...
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum SigOp {
    Terminate,
    CoreDump,
    Ignore,
    Stop,
    Continue,
}
```

`SigAction` 是信号处理的结构体，`sa_handler` 即用户自定义处理函数, `sa_flags` 即相应的标志位, `sa_restorer` 为当用户自定义处理函数运行完毕后跳转的地址, `sa_mask` 为运行该信号处理函数时需要阻塞的信号.

```rust
/// Signal action
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct SigAction {
    pub sa_handler: usize,
    pub sa_flags: SigActionFlags,
    pub sa_restore: usize,
    pub sa_mask: SignalFlags,
}
```

`KSigAction` 添加一个自定义标志判断是否使用默认处理函数.

```rust
#[derive(Clone, Copy)]
pub struct KSigAction {
    pub act: SigAction,
    pub customed: bool,
}

impl KSigAction {
    pub fn ignore() -> Self {
        Self {
            act: SigAction {
                sa_handler: 1,
                sa_flags: SigActionFlags::empty(),
                sa_restore: 0,
                sa_mask: SignalFlags::empty(),
            },
            customed: false,
        }
    }
}
```

`SigTable`  维护一个信号表，封装 `SigTableInner`，`group_exit_code` 是一个进程内多个线程的退出码. `actions` 即是信号表本身根据信号编号调用对应处理函数.

```rust
pub struct SigTableInner {
    actions: [KSigAction; SIG_MAX_NUM + 1],
    group_exit_code: Option<i32>,
}

impl SigTable {
	...
    pub fn action(&self, signo: usize) -> KSigAction {
        self.get_ref().actions[signo]
    }
    pub fn set_action(&self, signo: usize, act: KSigAction) {
        self.get_mut().actions[signo] = act
    }
    pub fn exit_code(&self) -> i32 {
        self.get_ref().group_exit_code.unwrap()
    }
    ...
}
```

#### 2.4.2 信号传递机制

信号的发送逻辑：

```rust
pub fn send_signal_to_thread(tid: usize, sig: SignalFlags) {
    let tid2task = TID2TCB.exclusive_access();
    if let Some(task) = tid2task.get(&tid) {
        add_signal(task.clone(), sig);
    }
}

pub fn add_signal(task: Arc<TaskControlBlock>, signal: SignalFlags) {
    let mut task_inner = task.inner_exclusive_access();
    task_inner.sig_pending |= signal;
}
```

即是在对应任务中添加待处理的信号。

内核对信号的处理如下，引自[Linux中的信号处理机制](https://zhuanlan.zhihu.com/p/79062142)：

<img src="https://pica.zhimg.com/v2-dffe4da0dc9611f74eaa5463c328a022_1440w.jpg" style="zoom:100%;" />

内核中的信号处理函数即是 `handle_signal()`.

```rust
pub fn handle_signal(signo: usize) {
    let task = current_task().unwrap();
    let process = task.process.upgrade().unwrap();
    let inner = process.inner_exclusive_access();
    let signal = SignalFlags::from_sig(signo);
    let sig_action = inner.sig_table.action(signo);
    drop(inner);
    let mut task_inner = task.inner_exclusive_access();
    task_inner.sig_pending.remove(signal);
    drop(task_inner);
    drop(task);
    if sig_action.customed {
        setup_frame(signo, sig_action);
    } else {
        if sig_action.act.sa_handler != 1 {
            if sig_action.act.sa_handler == exit_current_and_run_next as usize {
                exit_current_and_run_next((signo + 128) as i32);
            }
        }
    }
}
```

### 2.5 HAL 硬件抽象层

为了支持 RISC-V 和 LoongArch 两种架构，我们设计了硬件抽象层。

#### 2.5.1 架构适配设计

通过条件编译实现架构适配，例如：

```rust
/// print to the host console using the format string and arguments.
pub fn _print(args: Arguments) {
    #[cfg(target_arch = "riscv64")]
    Stdout.write_fmt(args).unwrap();
    #[cfg(target_arch = "loongarch64")]
    CONSOLE.lock().write_fmt(args).unwrap()
}
```

由于 RISCV 下可以直接为 `impl Write for Stdout` 来实现输出，而 LoongArch 下需要通过 Uart 来实现，因此需要在接口内部设置不同的处理方式，仅为上层提供统一的调用 API。

#### 2.5.2 内存管理适配

不同架构的内存管理差异通过 HAL 层统一，我们仿照了 polyhal 的设计，统一了上层的 `MapPermission` 接口：

```rust
bitflags! {
    /// map permission corresponding to that in pte: `R W X U`
    pub struct MapPermission: u8 {
        ///Readable
        const R = 1 << 1;
        ///Writable
        const W = 1 << 2;
        ///Excutable
        const X = 1 << 3;
        ///Accessible in U mode
        const U = 1 << 4;
    }
}
```

由于不同的页表项内容存在差异，因此我们设计了一个针对不同 `PTEFlags` 的转换机制，由此上层只需要考虑 `MapPermission` 而抹消了架构的标志位差异：

```rust
impl From<MapPermission> for PTEFlags {
    fn from(perm: MapPermission) -> Self {
        #[cfg(target_arch = "riscv64")]
        if perm.is_empty() {
            return PTEFlags::empty();
        } else {
            let mut res = PTEFlags::V;
            if perm.contains(MapPermission::R) {
                res |= PTEFlags::R | PTEFlags::A;
            }
            if perm.contains(MapPermission::W) {
                res |= PTEFlags::W | PTEFlags::D;
            }
            if perm.contains(MapPermission::X) {
                res |= PTEFlags::X;
            }
            if perm.contains(MapPermission::U) {
                res |= PTEFlags::U;
            }
            return res;
        }
        #[cfg(target_arch = "loongarch64")]
        if perm.is_empty() {
            return PTEFlags::empty();
        } else {
            let mut res = PTEFlags::V | PTEFlags::MAT_CC | PTEFlags::P;
            if !perm.contains(MapPermission::R) {
                res |= PTEFlags::NR;
            }
            if perm.contains(MapPermission::W) {
                res |= PTEFlags::W | PTEFlags::D;
            }
            if !perm.contains(MapPermission::X) {
                res |= PTEFlags::NX;
            }
            if perm.contains(MapPermission::U) {
                let plv3 = PTEFlags::PLVH | PTEFlags::PLVL;
                res |= plv3; // as PLV3, user mode
            }
            return res;
        }
    }
}
```

### 2.6 网络机制

我们实现了网络协议栈和 Socket 系统调用，支持 TCP 和 UDP 通信。

#### 2.6.1 Socket 系统调用

实现了 Socket 等系统调用：

```rust
pub fn sys_socket(domain: u32, socktype: u32, protocol: u32) -> isize {
    let (domain, socktype, protocol) = (domain as u32, socktype as u32, protocol as u32);
    let flags = OpenFlags::empty(); // Define flags here for both branches

    match (domain, socktype, protocol) {
        (AF_INET, SOCK_STREAM, IPPROTO_TCP) | (AF_INET, SOCK_STREAM, 0) => {
            let sock = Socket::Tcp(Mutex::new(TcpSocket::new()));
            let process = current_process();
            let inner = process.inner_exclusive_access();
            let fd = inner.fd_table.alloc_fd().unwrap();
            inner.fd_table.set(
                fd,
                FileDescriptor::new(flags, FileClass::Sock(Arc::new(sock))),
            );
            fd as isize
        }
        (AF_INET, SOCK_DGRAM, IPPROTO_UDP) | (AF_INET, SOCK_DGRAM, 0) => {
            let sock = Socket::Udp(Mutex::new(UdpSocket::new()));
            let process = current_process();
            let inner = process.inner_exclusive_access();
            let fd = inner.fd_table.alloc_fd().unwrap();
            inner.fd_table.set(
                fd,
                FileDescriptor::new(flags, FileClass::Sock(Arc::new(sock))),
            );
            fd as isize
        }
        _ => SysErrNo::EINVAL as isize,
    }
}
```

#### 2.6.2 网络协议栈

我们参考 StarryOS 和 BlusOS，基于 `smoltcp` 库实现网络协议栈：

```rust
pub enum Socket {
    Udp(Mutex<UdpSocket>),
    Tcp(Mutex<TcpSocket>),
}

impl Socket {
    pub fn send(&self, buf: &[u8]) -> AxResult<usize> {
        match self {
            Socket::Udp(udpsocket) => Ok(udpsocket.lock().send(buf)?),
            Socket::Tcp(tcpsocket) => Ok(tcpsocket.lock().send(buf)?),
        }
    }

    pub fn recv(&self, buf: &mut [u8]) -> AxResult<usize> {
        match self {
            Socket::Udp(udpsocket) => Ok(udpsocket.lock().recv(buf)?),
            Socket::Tcp(tcpsocket) => Ok(tcpsocket.lock().recv(buf)?),
        }
    }
}
```

底层具体实现：

```rust
pub struct TcpSocket {
    state: AtomicU8,
    handle: UnsafeCell<Option<SocketHandle>>,
    local_addr: UnsafeCell<IpEndpoint>,
    peer_addr: UnsafeCell<IpEndpoint>,
    nonblock: AtomicBool,
}

unsafe impl Sync for TcpSocket {}

impl TcpSocket {
    /// Creates a new TCP socket.
    pub const fn new() -> Self {
        Self {
            state: AtomicU8::new(STATE_CLOSED),
            handle: UnsafeCell::new(None),
            local_addr: UnsafeCell::new(UNSPECIFIED_ENDPOINT),
            peer_addr: UnsafeCell::new(UNSPECIFIED_ENDPOINT),
            nonblock: AtomicBool::new(false),
        }
    }

    /// Creates a new TCP socket that is already connected.
    const fn new_connected(
        handle: SocketHandle,
        local_addr: IpEndpoint,
        peer_addr: IpEndpoint,
    ) -> Self {
        Self {
            state: AtomicU8::new(STATE_CONNECTED),
            handle: UnsafeCell::new(Some(handle)),
            local_addr: UnsafeCell::new(local_addr),
            peer_addr: UnsafeCell::new(peer_addr),
            nonblock: AtomicBool::new(false),
        }
    }

    /// Returns the local address and port, or
    /// [`Err(NotConnected)`](AxError::NotConnected) if not connected.
    #[inline]
    pub fn local_addr(&self) -> AxResult<SocketAddr> {
        match self.get_state() {
            STATE_CONNECTED | STATE_LISTENING | STATE_CLOSED => {
                Ok(into_core_sockaddr(unsafe { self.local_addr.get().read() }))
            }
            _ => Err(AxError::NotConnected),
        }
    }
}
```

## 3. 总结与展望

`SubsToKernel` 在决赛阶段完成了一个功能相对完整的操作系统内核实现，成功实现了文件系统、信号机制以及网络功能。从初始化仓库到现在，团队成员通过良好的沟通协作和夜以继日的努力，克服了众多技术难题。

我们在实现过程中参考了许多优秀的开源项目，例如 [TrustOS](https://gitlab.eduxiji.net/rusttrusthuster/oskernel2024-trustos)、[rCoreloongArch](https://github.com/Godones/rCoreloongArch)、[chaos](https://github.com/chaos-kernel/chaos/tree/main) 和 [NPUcore-IMPACT](https://github.com/Fediory/NPUcore-IMPACT/tree/NPUcore-FF) 等项目。

主要成就：
- 实现了完整的进程和线程管理机制
- 设计 RISC-V 和 LoongArch 双架构
- 集成了 EXT4 文件系统支持
- 实现了 POSIX 信号机制
- 完成了网络协议栈和一些网络相关的 syscalls 实现
- 设计了可扩展的 HAL 硬件抽象层

下一阶段的目标是继续完善系统调用实现，优化性能，并朝着实现更完整完善的操作系统推进：
- 完善系统调用覆盖率
- 优化内存管理和调度性能
- 增强网络功能和安全性
- 支持更多文件系统类型
- 实现多核支持